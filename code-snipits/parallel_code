use std::fmt::Write;
use std::io;
use std::iter::FromIterator;

use bytes::{BufMut, Bytes, BytesMut};
use futures::{future, stream, Stream};
use tokio::codec::{BytesCodec, FramedRead, FramedWrite};
use tokio::prelude::*;
use tokio::runtime::Runtime;

use parallel_stream::StreamExt;
use word_count::util::*;

const CHUNKS_CAPACITY: usize = 256;
const BUFFER_SIZE: usize = 4;

fn main() {
    let conf = parse_args("word count parallel buf");
    let mut runtime = Runtime::new().expect("can't create runtime");
    let mut exec = runtime.executor();

    let (input, output) = open_io_async(&conf);
    let input_stream = FramedRead::new(input, WholeWordsCodec::new());
    let output_stream = FramedWrite::new(output, BytesCodec::new());

    let task = input_stream
        .fork(conf.threads, BUFFER_SIZE, &mut exec)
        .instrumented_fold(
            || FreqTable::new(),
            |mut frequency, text| {
                count_bytes(&mut frequency, &text);
                future::ok(frequency)
            },
            "split_and_count".to_owned(),
        )
        .merge(
            FreqTable::new(),
            |mut frequency, sub_table| {
                for (word, count) in sub_table {
                    *frequency.entry(word).or_insert(0) += count;
                }
                future::ok(frequency)
            },
            &mut exec,
        )
        .map_err(|e| io::Error::new(io::ErrorKind::Other, format!("recv error: {:#?}", e)))
        .map(|frequency_map| {
            let mut frequency = Vec::from_iter(frequency_map);
            frequency.sort_unstable_by(|(ref w_a, ref f_a), (ref w_b, ref f_b)| {
                f_b.cmp(&f_a).then(w_b.cmp(&w_a))
            });
            stream::iter_ok(frequency).chunks(CHUNKS_CAPACITY) 
        })
        .flatten_stream()
        .instrumented_map(
            |chunk: Vec<(Bytes, u64)>| {
                let mut buffer = BytesMut::with_capacity(CHUNKS_CAPACITY * 15);
                for (word_raw, count) in chunk {
                    let word = utf8(&word_raw).expect("UTF8 encoding error");
                    let max_len = word_raw.len() + 15;
                    if buffer.remaining_mut() < max_len {
                        buffer.reserve(10 * max_len);
                    }
                    buffer
                        .write_fmt(format_args!("{} {}\n", word, count))
                        .expect("Formating error");
                }
                buffer.freeze()
            },
            "format_chunk".to_owned(),
        )
        .forward(output_stream)
        .map_err(|e| panic!("processing error: {:#?}", e));

    let (_word_stream, _out_file) = runtime.block_on(task).expect("error running main task");

    runtime.shutdown_on_idle();
}
