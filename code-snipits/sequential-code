use std::io;
use std::io::Result as StdResult;
use std::iter::FromIterator;

use bytes::Bytes;
use parallel_stream::StreamExt;
use tokio::codec::{BytesCodec, FramedRead, FramedWrite};
use tokio::prelude::*;
use tokio::runtime::Runtime;
use word_count::util::*;

fn main() -> StdResult<()> {
    let conf = parse_args("word count async buf");
    let mut runtime = Runtime::new()?;
    let (input, output) = open_io_async(&conf);

    let input_stream = FramedRead::new(input, WholeWordsCodec::new());
    let output_stream = FramedWrite::new(output, BytesCodec::new());

    let dbg_future = input_stream
        .instrumented_fold(
            FreqTable::new(),
            |mut frequency, text| {
                count_bytes(&mut frequency, &text);

                future::ok::<FreqTable, io::Error>(frequency)
            },
            "split_and_count".to_owned(),
        )
        .map(|frequency| {
            let sort_time = Instant::now();
            let mut frequency_vec = Vec::from_iter(frequency);
            frequency_vec.sort_unstable_by(|(ref w_a, ref f_a), (ref w_b, ref f_b)| {
                f_b.cmp(&f_a).then(w_b.cmp(&w_a))
            });
            eprintln!("sorttime:{:?}", sort_time.elapsed());
            stream::iter_ok(frequency_vec)
        })
        .flatten_stream()
        .instrumented_map(
            |(word_raw, count)| {
                let word = ::std::str::from_utf8(&word_raw).expect("UTF8 encoding error");
                Bytes::from(format!("{} {}\n", word, count))
            },
            "format".to_owned(),
        )
        .forward(output_stream);

    let (_, _output_stream) = runtime.block_on(dbg_future)?;
    runtime.shutdown_on_idle();

    Ok(())
}
